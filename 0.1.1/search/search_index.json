{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Background \u00b6 In 2022 I decided to take my home office / workshop / mancave and move it off-grid. Armed with a vision, (very) limited skills, and some weekends I set forth to design a system which would allow me to generate my own electricity whilst I worked from home (circa. 3days a week) and become 100% self-sufficient. I wanted to be able to create, store, and maximise the efficiency electricity within the building. Being a tech and data junkie this meant integrating various systems to provide holistic information and learning new protocols. This repository is designed to document my approach to setting up a basic Home Assistant installation with a connection to Victron Energy devices (solar mppt charge controller, battery smartshunt, inverter etc.). Many of the settings will require changing for your local configuration so please read the documentation before attempting to blindly run a docker compose up -d . For details on what's included in the documentation and planned in the future refer to the Roadmap . How to use this documentation \u00b6 The documentation is structured into a few sections: Lessons Learned : let's do this upfront... key things I've learned, mistakes made, and what I'd do differently next time. Getting Started: what you're going to need to attempt the same as me System Overview : high level design and decisions for the system Home Assistant: the brains of the operation Victron Energy: setup and integration of Victron solar and energy storage","title":"Project Ra"},{"location":"#background","text":"In 2022 I decided to take my home office / workshop / mancave and move it off-grid. Armed with a vision, (very) limited skills, and some weekends I set forth to design a system which would allow me to generate my own electricity whilst I worked from home (circa. 3days a week) and become 100% self-sufficient. I wanted to be able to create, store, and maximise the efficiency electricity within the building. Being a tech and data junkie this meant integrating various systems to provide holistic information and learning new protocols. This repository is designed to document my approach to setting up a basic Home Assistant installation with a connection to Victron Energy devices (solar mppt charge controller, battery smartshunt, inverter etc.). Many of the settings will require changing for your local configuration so please read the documentation before attempting to blindly run a docker compose up -d . For details on what's included in the documentation and planned in the future refer to the Roadmap .","title":"Background"},{"location":"#how-to-use-this-documentation","text":"The documentation is structured into a few sections: Lessons Learned : let's do this upfront... key things I've learned, mistakes made, and what I'd do differently next time. Getting Started: what you're going to need to attempt the same as me System Overview : high level design and decisions for the system Home Assistant: the brains of the operation Victron Energy: setup and integration of Victron solar and energy storage","title":"How to use this documentation"},{"location":"lessons-learned/","text":"Some of the things that I've learned along the way that are worth referencing upfront... You'll likely need batteries, even if you're not interested in storing long term \u00b6 Ultimately the loads on the circuit will dictate but I found out the hard way that solar panels + charge controller alone simply couldn't compensate for the spikes for kit such as coffee machines. The pull was too great in too short a period and so the inverter turned off with \"low voltage\" errors. Connecting the batteries provided a stable \"burst\" capacity to fill in the gaps and I no longer had any issues afterwards. Grid connecting power requires specialist kit \u00b6 As detailed in the system overview section I've gone with Victron Energy kit wherever possible and have utilised eBay heavily for second hand components to keep costs down. I therefore ended up with a Phoenix Inverter which is designed for 100% off-grid living and comfortably handles 1,000W of AC output. What it doesn't do however is handle grid connections. If, for example, I wanted to output power into the house (or augment low power from the PV panels with grid energy) this would be physically impossible. You need to have both AC power sources (grid and inverter) synchronise their waveforms otherwise they fight each other and simply wont work. You'll only be able to power a circuit with a single source, so pick the right one. Phoenix Inverter diagram source: Victron Energy: Phoenix Inverter Compact documentation My understanding is that kit such as the Multiplus II range or dedicated micro-inverters can handle this. Multiplus II diagram source: Victron Energy: Multiplus II documentation This is fine for my use case - where I'm expecting to create more energy over the 4days a week I'm not in the building than I consume in the 3days I am - but for others you may need to adjust your purchasing (or system design) accordingly. Cable sizing is important \u00b6 This might seem obvious but the thickness of the cables purchased impact two things primarily: Ampacity (throughput) that can be supported. Think of it like the width of a road / number of lanes. Standard measures are referenced in both cross-sectional area (mm2) and diameter (mm) so ensure you understand the difference whilst the US AWG (American Wire Guage) provides another widely used method. In UK houses we use 2.5mm2 cabling for the mains circuits which are rated to around 20A (hence why most of your breakers in the consumer unit are 16A for safety). The voltage drop that can be experienced. Think of it like the resistance in the cable and, the longer it is (and the higher the resistance), the more likely it is that you'll lose power between one end of the cable and the other. There are industry standards for both of the above (and online calculators) so just make sure you check. The larger the cable the better for our use cases though in general. The voltage drop could catch you out if you're taking low voltage from solar panels (eg. 32V), running the output through long, thing cables into a charge controller (which needs a certain voltage to even turn on), and then intending to charge batteries with a voltage of 24V. Doesn't leave a lot of margin for error. I sense checked my cable (before cutting any lengths) by temporarily wiring a single panel into the entire drum of PV cable (circa. 50m) and measuring the resulting voltage at the other end of it. Theory being that if it was ok after the full 50m then I didn't need to worry about smaller lengths. It's cheaper to heat a person than a space \u00b6 I have a relatively simple 800W electric radiator which was previously set to keep the building at a set temperature when I was due to be working in it. During the winter it came on at 0600, started heating the office, and quickly reduced my available battery down to ~30% before the solar kicked in and started to recharge it. Bear this in mind. It's easier to put on another layer, have a blanket etc. than attempt to heat an entire space if you don't need to. I'd rather save the power for something else 9 times out of 10. source: Victron Energy VRM portal You'll probably want the Cerbo GX on Ethernet \u00b6 Because when you turn off the inverter or disconnect AC loads for any reason the WiFi Access Point will disappear and you won't be able to connect to turn it back on ...! The Skylla-i battery charger needs to be shorted \u00b6 If you aren't going to use the voltage sensors (like me) because you're going to control the device in another way / use as a direct power supply make sure you pass a small wire between the two terminals in order to short it. Otherwise it'll simply not start - lost a day of my life with this one... read the manual! Skylla-i photo Showing required cable for shorting the Skylla-i.","title":"Lessons Learned"},{"location":"lessons-learned/#youll-likely-need-batteries-even-if-youre-not-interested-in-storing-long-term","text":"Ultimately the loads on the circuit will dictate but I found out the hard way that solar panels + charge controller alone simply couldn't compensate for the spikes for kit such as coffee machines. The pull was too great in too short a period and so the inverter turned off with \"low voltage\" errors. Connecting the batteries provided a stable \"burst\" capacity to fill in the gaps and I no longer had any issues afterwards.","title":"You'll likely need batteries, even if you're not interested in storing long term"},{"location":"lessons-learned/#grid-connecting-power-requires-specialist-kit","text":"As detailed in the system overview section I've gone with Victron Energy kit wherever possible and have utilised eBay heavily for second hand components to keep costs down. I therefore ended up with a Phoenix Inverter which is designed for 100% off-grid living and comfortably handles 1,000W of AC output. What it doesn't do however is handle grid connections. If, for example, I wanted to output power into the house (or augment low power from the PV panels with grid energy) this would be physically impossible. You need to have both AC power sources (grid and inverter) synchronise their waveforms otherwise they fight each other and simply wont work. You'll only be able to power a circuit with a single source, so pick the right one. Phoenix Inverter diagram source: Victron Energy: Phoenix Inverter Compact documentation My understanding is that kit such as the Multiplus II range or dedicated micro-inverters can handle this. Multiplus II diagram source: Victron Energy: Multiplus II documentation This is fine for my use case - where I'm expecting to create more energy over the 4days a week I'm not in the building than I consume in the 3days I am - but for others you may need to adjust your purchasing (or system design) accordingly.","title":"Grid connecting power requires specialist kit"},{"location":"lessons-learned/#cable-sizing-is-important","text":"This might seem obvious but the thickness of the cables purchased impact two things primarily: Ampacity (throughput) that can be supported. Think of it like the width of a road / number of lanes. Standard measures are referenced in both cross-sectional area (mm2) and diameter (mm) so ensure you understand the difference whilst the US AWG (American Wire Guage) provides another widely used method. In UK houses we use 2.5mm2 cabling for the mains circuits which are rated to around 20A (hence why most of your breakers in the consumer unit are 16A for safety). The voltage drop that can be experienced. Think of it like the resistance in the cable and, the longer it is (and the higher the resistance), the more likely it is that you'll lose power between one end of the cable and the other. There are industry standards for both of the above (and online calculators) so just make sure you check. The larger the cable the better for our use cases though in general. The voltage drop could catch you out if you're taking low voltage from solar panels (eg. 32V), running the output through long, thing cables into a charge controller (which needs a certain voltage to even turn on), and then intending to charge batteries with a voltage of 24V. Doesn't leave a lot of margin for error. I sense checked my cable (before cutting any lengths) by temporarily wiring a single panel into the entire drum of PV cable (circa. 50m) and measuring the resulting voltage at the other end of it. Theory being that if it was ok after the full 50m then I didn't need to worry about smaller lengths.","title":"Cable sizing is important"},{"location":"lessons-learned/#its-cheaper-to-heat-a-person-than-a-space","text":"I have a relatively simple 800W electric radiator which was previously set to keep the building at a set temperature when I was due to be working in it. During the winter it came on at 0600, started heating the office, and quickly reduced my available battery down to ~30% before the solar kicked in and started to recharge it. Bear this in mind. It's easier to put on another layer, have a blanket etc. than attempt to heat an entire space if you don't need to. I'd rather save the power for something else 9 times out of 10. source: Victron Energy VRM portal","title":"It's cheaper to heat a person than a space"},{"location":"lessons-learned/#youll-probably-want-the-cerbo-gx-on-ethernet","text":"Because when you turn off the inverter or disconnect AC loads for any reason the WiFi Access Point will disappear and you won't be able to connect to turn it back on ...!","title":"You'll probably want the Cerbo GX on Ethernet"},{"location":"lessons-learned/#the-skylla-i-battery-charger-needs-to-be-shorted","text":"If you aren't going to use the voltage sensors (like me) because you're going to control the device in another way / use as a direct power supply make sure you pass a small wire between the two terminals in order to short it. Otherwise it'll simply not start - lost a day of my life with this one... read the manual! Skylla-i photo Showing required cable for shorting the Skylla-i.","title":"The Skylla-i battery charger needs to be shorted"},{"location":"system-overview/","text":"","title":"System overview"},{"location":"todo/","text":"Documentation Roadmap \u00b6 The below is a (non-exhaustive) list of what I'm planning to add over time to the documentation. Core: Repository orientation Documentation: Lessons Learned Getting Started System Overview Home Assistant Victron Energy","title":"Roadmap"},{"location":"todo/#documentation-roadmap","text":"The below is a (non-exhaustive) list of what I'm planning to add over time to the documentation. Core: Repository orientation Documentation: Lessons Learned Getting Started System Overview Home Assistant Victron Energy","title":"Documentation Roadmap"},{"location":"getting-started/pre-reqs/","text":"Acceptance of Liability I shouldn't really need to say this... but I will anyway. This documentation is intended for my own reference and learning. Nothing within it should be taken as official electrical guidance etc. etc. and by following any of my instructions (and tailoring for your own circumstances) you are assuming all liability for your own actions! \ud83e\udd26\u200d\u2642\ufe0f Before embarking on this quest you'll need to ensure you meet some of the below pre-requisites. Whether you want to use Home Assistant or not is a matter of personal choice - it's not required for this. I'm including integration instructions for completeness purposes as I'll document the HA setup separately to keep this repository focussed. The custom automation I have for controlling charge of the batteries during off-peak hours is pure Python in this repository and can be run independently of any host automation controller. Home Assistant \u00b6 There are instructions in the getting started section of the Home Assistant website. Choose your own adventure but my own personal setup uses a Docker container as part of a wider orchestration. As a result instructions will be specific to that and may need tweaking for your own environment. Victron Energy Devices \u00b6 Regardless of if you're attending to integrate Victron Energy Devices to your Home Assistant installation or simply control them via the exposed Modbus services over TCP you'll need access to either a Cerbo GX or homebrewed Venus OS device. For the sake of ease I've used a Cerbo GX. This device acts as an aggregator for the Victron kit across a variety of protocols (CAN, Modbus, VE.Direct etc.) and will provide us with a single endpoint for managing them over TCP after you connect via either WiFi or Ethernet (ideally, see lessons learned ).","title":"Pre Reqs"},{"location":"getting-started/pre-reqs/#home-assistant","text":"There are instructions in the getting started section of the Home Assistant website. Choose your own adventure but my own personal setup uses a Docker container as part of a wider orchestration. As a result instructions will be specific to that and may need tweaking for your own environment.","title":"Home Assistant"},{"location":"getting-started/pre-reqs/#victron-energy-devices","text":"Regardless of if you're attending to integrate Victron Energy Devices to your Home Assistant installation or simply control them via the exposed Modbus services over TCP you'll need access to either a Cerbo GX or homebrewed Venus OS device. For the sake of ease I've used a Cerbo GX. This device acts as an aggregator for the Victron kit across a variety of protocols (CAN, Modbus, VE.Direct etc.) and will provide us with a single endpoint for managing them over TCP after you connect via either WiFi or Ethernet (ideally, see lessons learned ).","title":"Victron Energy Devices"},{"location":"victron/home-assistant/","text":"Example This is an optional step to help to integrate the exposed ModbusTCP services from the Victron devices with a Home Assistant instance. In order to integrate our above ModbusTCP understanding into Home Assistant we need to perform a few steps: Enable the Modbus extension - inside the configuration.yaml ; Provide this extension with a list of available services and how to interpret them - inside the modbus.yaml ; and Explain how to translate the returned enums into human readable responses - inside the sensor/modbus_sensor.yaml file. Modbus extension: configuration.yaml \u00b6 Home Assistant comes with an inbuilt extension to support the Modbus protocol. Full documentation can be found here . The extension needs to be enabled within the configuration.yaml file however as opposed to being added via the UI. configuration.yaml modbus : !include modbus.yaml # Includes all Templates / Sensors in folder sensor sensor : !include_dir_merge_list sensor/ We're going to follow a separation of concerns and keep our modbus service configuration in a separate file called modbus.yaml . Our templates (for displaying enums) will be within a dedicated sensor/sensor_modbus.yaml file. The folder structure will therefore look as follows: Bash config \u251c\u2500\u2500 configuration.yaml \u251c\u2500\u2500 modbus.yaml \u251c\u2500\u2500 secrets.yaml \u2514\u2500\u2500 sensor \u2514\u2500\u2500 sensor_modbus.yaml Services: modbus.yaml \u00b6 The modbus.yaml file configures the extension with the known endpoints for our Cerbo GX, the connected devices, and their capabilities (published as services). An example is given below, simply add additional entries into the sensors section the mapping of yaml to the spreadsheet above should be fairly obvious, with the exception of the scale (needs to be 1 / [scalefactor] ) and precision (how accurate the value is in decimal places). modbus.yaml - name : \"victron\" type : tcp delay : 5 timeout : 5 host : !secret cerbo_ip port : 502 sensors : - name : \"Battery Voltage (System)\" # Battery Voltage determined from different measurements. In order of preference: BMV-voltage (V), Multi-DC-Voltage (CV), MPPT-DC-Voltage (ScV), Charger voltage scan_interval : 10 address : 840 slave : !secret com.victronenergy.system data_type : uint16 unit_of_measurement : \"V DC\" device_class : voltage scale : 0.1 precision : 1 - name : \"Battery Current (System)\" # Postive: battery begin charged. Negative: battery being discharged scan_interval : 10 address : 841 slave : !secret com.victronenergy.system data_type : int16 unit_of_measurement : \"A DC\" device_class : current scale : 0.1 precision : 1 - name : \"Battery Power (System)\" # Postive: battery begin charged. Negative: battery being discharged scan_interval : 10 address : 842 slave : !secret com.victronenergy.system data_type : int16 unit_of_measurement : \"W\" device_class : energy scale : 1 - name : \"Battery State of Charge (System)\" # Best battery state of charge, determined from different measurements. scan_interval : 10 address : 843 slave : !secret com.victronenergy.system data_type : uint16 unit_of_measurement : \"%\" device_class : battery scale : 1 - name : \"Battery state (System)\" # 0=idle;1=charging;2=discharging scan_interval : 10 address : 844 slave : !secret com.victronenergy.system data_type : int16 device_class : battery scale : 1 Templates: sensor/sensor_modbus.yaml \u00b6 This has to be done in hideous yaml unfortunately using jinja2 syntax... We use if then else type flows in order to return the correct human readable representation of the enum. NB: Note how we are referencing battery_state_system as the root sensor. Home Assistant will automatically escape the human readable \"Battery state (System)\" description given to it in our modbus.yaml file originally. sensor/sensor_modbus.yaml - platform : template sensors : battery_state_system_friendly : friendly_name : \"Battery State (System)\" # 0=idle;1=charging;2=discharging value_template : >- {% if (states('sensor.battery_state_system') | int(default=0) == 0) %} Idle {% elif (states('sensor.battery_state_system') | int(default=0) == 1) %} Charging {% elif (states('sensor.battery_state_system') | int(default=0) == 2) %} Discharging {% else %} ERROR {% endif %} You should now be able to create a card within Home Assistant that contains the details and history for the system battery. Sources \u00b6 Thanks to the following for resources used in this process of learning: Victron Energy Forums: HA Modbus Integration Tutorial lucode/home-assistant Home Assistant: Modbus Victron Energy: GC Modbus-TCP Manual","title":"Home Assistant"},{"location":"victron/home-assistant/#modbus-extension-configurationyaml","text":"Home Assistant comes with an inbuilt extension to support the Modbus protocol. Full documentation can be found here . The extension needs to be enabled within the configuration.yaml file however as opposed to being added via the UI. configuration.yaml modbus : !include modbus.yaml # Includes all Templates / Sensors in folder sensor sensor : !include_dir_merge_list sensor/ We're going to follow a separation of concerns and keep our modbus service configuration in a separate file called modbus.yaml . Our templates (for displaying enums) will be within a dedicated sensor/sensor_modbus.yaml file. The folder structure will therefore look as follows: Bash config \u251c\u2500\u2500 configuration.yaml \u251c\u2500\u2500 modbus.yaml \u251c\u2500\u2500 secrets.yaml \u2514\u2500\u2500 sensor \u2514\u2500\u2500 sensor_modbus.yaml","title":"Modbus extension: configuration.yaml"},{"location":"victron/home-assistant/#services-modbusyaml","text":"The modbus.yaml file configures the extension with the known endpoints for our Cerbo GX, the connected devices, and their capabilities (published as services). An example is given below, simply add additional entries into the sensors section the mapping of yaml to the spreadsheet above should be fairly obvious, with the exception of the scale (needs to be 1 / [scalefactor] ) and precision (how accurate the value is in decimal places). modbus.yaml - name : \"victron\" type : tcp delay : 5 timeout : 5 host : !secret cerbo_ip port : 502 sensors : - name : \"Battery Voltage (System)\" # Battery Voltage determined from different measurements. In order of preference: BMV-voltage (V), Multi-DC-Voltage (CV), MPPT-DC-Voltage (ScV), Charger voltage scan_interval : 10 address : 840 slave : !secret com.victronenergy.system data_type : uint16 unit_of_measurement : \"V DC\" device_class : voltage scale : 0.1 precision : 1 - name : \"Battery Current (System)\" # Postive: battery begin charged. Negative: battery being discharged scan_interval : 10 address : 841 slave : !secret com.victronenergy.system data_type : int16 unit_of_measurement : \"A DC\" device_class : current scale : 0.1 precision : 1 - name : \"Battery Power (System)\" # Postive: battery begin charged. Negative: battery being discharged scan_interval : 10 address : 842 slave : !secret com.victronenergy.system data_type : int16 unit_of_measurement : \"W\" device_class : energy scale : 1 - name : \"Battery State of Charge (System)\" # Best battery state of charge, determined from different measurements. scan_interval : 10 address : 843 slave : !secret com.victronenergy.system data_type : uint16 unit_of_measurement : \"%\" device_class : battery scale : 1 - name : \"Battery state (System)\" # 0=idle;1=charging;2=discharging scan_interval : 10 address : 844 slave : !secret com.victronenergy.system data_type : int16 device_class : battery scale : 1","title":"Services: modbus.yaml"},{"location":"victron/home-assistant/#templates-sensorsensor_modbusyaml","text":"This has to be done in hideous yaml unfortunately using jinja2 syntax... We use if then else type flows in order to return the correct human readable representation of the enum. NB: Note how we are referencing battery_state_system as the root sensor. Home Assistant will automatically escape the human readable \"Battery state (System)\" description given to it in our modbus.yaml file originally. sensor/sensor_modbus.yaml - platform : template sensors : battery_state_system_friendly : friendly_name : \"Battery State (System)\" # 0=idle;1=charging;2=discharging value_template : >- {% if (states('sensor.battery_state_system') | int(default=0) == 0) %} Idle {% elif (states('sensor.battery_state_system') | int(default=0) == 1) %} Charging {% elif (states('sensor.battery_state_system') | int(default=0) == 2) %} Discharging {% else %} ERROR {% endif %} You should now be able to create a card within Home Assistant that contains the details and history for the system battery.","title":"Templates: sensor/sensor_modbus.yaml"},{"location":"victron/home-assistant/#sources","text":"Thanks to the following for resources used in this process of learning: Victron Energy Forums: HA Modbus Integration Tutorial lucode/home-assistant Home Assistant: Modbus Victron Energy: GC Modbus-TCP Manual","title":"Sources"},{"location":"victron/off-peak-charging/","text":"Using the previously exposed modbus services I'm using a basic python script in order to toggle my battery charger on/off. This allows me to top up my batteries overnight to 100% using grid power using my energy provider's cheap tariff (circa. 25% of normal cost, designed for EVs). The only requirement you'll need can be installed with a python - m pip install 'pymodbus[serial]' . Automated Charging Script victron_charge.py \"\"\" --- Victron ArbitCharge --- Script to automate, via ModbusTCP, the charging of batteries using an off-peak utility tariff. Author: James Veitch Date: September 2022 \"\"\" import logging import sys from dataclasses import dataclass from datetime import datetime , timedelta from logging.handlers import RotatingFileHandler from os import environ , makedirs from pathlib import Path from time import sleep from typing import List , Tuple # needed for < 3.9 compat from pymodbus.client import ModbusTcpClient # --- LOGGING format = \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" logging . basicConfig ( format = format ) log = logging . getLogger ( __name__ if __name__ != \"__main__\" else \"charger\" ) LOG_LEVEL : str = environ . get ( \"LOG_LEVEL\" , \"INFO\" ) log . setLevel ( logging . _nameToLevel [ LOG_LEVEL ]) log . info ( f \"Logging started and set to ( { log . level } : { logging . _levelToName [ log . level ] } )\" ) LOG_FILE : str = environ . get ( \"LOG_FILE\" , \"~/.logs/charger.log\" ) try : LOG_FILE = Path ( LOG_FILE ) . expanduser () except Exception as e : log . error ( e ) log . critical ( f \"Unable to use log file of { LOG_FILE } . Terminating.\" ) sys . exit ( 1 ) makedirs ( LOG_FILE . parent , exist_ok = True ) fh : RotatingFileHandler = RotatingFileHandler ( LOG_FILE , mode = \"a+\" , maxBytes = 2048 , backupCount = 3 , encoding = \"utf-8\" ) fh . setFormatter ( logging . Formatter ( format )) log . addHandler ( fh ) log . info ( f \"Log file can be found at { fh . baseFilename } \" ) # --- VARIABLES # read from environment or commandline VENUS_IP_OR_HOSTNAME : str = environ . get ( \"VENUS_IP_OR_HOSTNAME\" , \"einstein.local\" ) BATTERY_SLAVE_UNIT_ID : int = environ . get ( \"BATTERY_SLAVE_UNIT_ID\" , 100 ) BATTERY_STATE_REGISTER_ADDRESS : int = environ . get ( \"BATTERY_STATE_REGISTER_ADDRESS\" , 843 ) BATTERY_SCALE_FACTOR : float = environ . get ( \"BATTERY_SCALE_FACTOR\" , 1 ) BATTERY_MIN_SOC : int = environ . get ( \"BATTERY_MIN_SOC\" , 50 ) BATTERY_MAX_SOC : int = environ . get ( \"BATTERY_MAX_SOC\" , 100 ) CHARGER_SLAVE_UNIT_ID : int = environ . get ( \"CHARGER_SLAVE_UNIT_ID\" , 100 ) CHARGER_STATE_REGISTER_ADDRESS : int = environ . get ( \"CHARGER_STATE_REGISTER_ADDRESS\" , 2317 ) CHARGER_START_TIME : datetime = datetime . strptime ( environ . get ( \"CHARGER_START_TIME\" , \"00:30\" ), \"%H:%M\" ) . time () CHARGER_FINISH_TIME : datetime = datetime . strptime ( environ . get ( \"CHARGER_FINISH_TIME\" , \"04:30\" ), \"%H:%M\" ) . time () # charger state management @dataclass class ChargerState : code : int name : str CHARGER_POTENTIAL_STATES : List [ ChargerState ] = [ ChargerState ( 0 , \"Off\" ), ChargerState ( 1 , \"On\" ), ChargerState ( 2 , \"Error\" ), ChargerState ( 3 , \"Unavailable - Unknown\" ), ] RETRIES : int = 0 # --- MAIN CODE def _find_state_by_code ( code : int ) -> ChargerState : state = [ state for state in CHARGER_POTENTIAL_STATES if state . code == code ] return state [ 0 ] if len ( state ) == 1 else None def get_client ( host : str = VENUS_IP_OR_HOSTNAME ) -> ModbusTcpClient : return ModbusTcpClient ( host ) def get_battery_soc ( unit_id : int = BATTERY_SLAVE_UNIT_ID , address : int = BATTERY_STATE_REGISTER_ADDRESS , scale_factor : float = BATTERY_SCALE_FACTOR , ): with get_client () as client : response = client . read_holding_registers ( address , slave = unit_id ) charge : int = response . registers [ 0 ] return round ( float ( charge ) / scale_factor ) def get_charger_state ( unit_id : int = CHARGER_SLAVE_UNIT_ID , address : int = CHARGER_STATE_REGISTER_ADDRESS ) -> ChargerState : with get_client () as client : response = client . read_holding_registers ( address , slave = unit_id ) state_code : int = response . registers [ 0 ] state : ChargerState = _find_state_by_code ( state_code ) return state def set_charger_state ( unit_id : int = CHARGER_SLAVE_UNIT_ID , address : int = CHARGER_STATE_REGISTER_ADDRESS , state_code : int = 1 , max_retries : int = 5 , ): global RETRIES current_state : ChargerState = get_charger_state () desired_state : ChargerState = _find_state_by_code ( state_code ) if current_state != desired_state : log . info ( f \"Changing charger state from { current_state } --> { desired_state } \" ) with get_client () as client : _ = client . write_registers ( address , desired_state . code , slave = unit_id ) sleep ( 3 ) current_state : ChargerState = get_charger_state () if current_state != desired_state : RETRIES += 1 if RETRIES > max_retries : log . critical ( \"Unable to change state. Max retries exceeded.\" ) return log . error ( f \"Unable to confirm state change. Retrying (attempt: { RETRIES } ) ...\" ) set_charger_state ( unit_id , address , state_code ) else : log . info ( f \"Charger state is already { current_state } \" ) def _get_start_and_finish_datetimes ( start : datetime = CHARGER_START_TIME , finish : datetime = CHARGER_FINISH_TIME ) -> Tuple [ datetime , datetime ]: now : datetime = datetime . now () start : datetime = datetime ( now . year , now . month , now . day , CHARGER_START_TIME . hour , CHARGER_START_TIME . minute ) finish : datetime = datetime ( now . year , now . month , now . day , CHARGER_FINISH_TIME . hour , CHARGER_FINISH_TIME . minute , ) if start < finish : return start , finish else : return start , ( finish + timedelta ( days = 1 )) def main (): timenow = datetime . now () start , finish = _get_start_and_finish_datetimes () log . info ( f \"Running between { start } and { finish } \" ) while start <= timenow < finish : timenow = datetime . now () # Get battery SoC and determine whether charging required still battery_soc : int = get_battery_soc () battery_needs_charging : bool = BATTERY_MIN_SOC <= battery_soc < BATTERY_MAX_SOC if battery_needs_charging : set_charger_state ( state_code = 1 ) else : log . info ( f \"Battery no longer needs charging at { battery_soc } %. Disabling charger.\" ) set_charger_state ( state_code = 0 ) sleep ( 60 ) log . info ( f \"Time of { timenow } is outside of charge window. Disabling charger.\" ) set_charger_state ( state_code = 0 ) if __name__ == \"__main__\" : main () The above script can be hooked into something as straightforward as a cron job and checks: if the system time is between CHARGER_START_TIME and CHARGER_FINISH_TIME ; and battery state of charge is between BATTERY_MIN_SOC and BATTERY_MAX_SOC . Based on the results it will then connects to the Cerbo GX device at VENUS_IP_OR_HOSTNAME and set the desired charger state accordingly.","title":"Automation: Charge during off-peak"},{"location":"victron/victron/","text":"This section describes how to expose Victron Energy device services on your wider network and, optionally, integrate into Home Assistant. Enable Modbus TCP \u00b6 Go to the remote console for the Cerbo GX device and ensure Modbus is enabled (it's disabled by default). Settings >> Services >> Modbus TCP >> Select Enabled Next click into the Available services section of this menu and you should see a list of entries with familiar looking descriptions to your victron devices such as SmartShunt and associated Unit ID values (which we will require for identifying them later on). In my setup I have the following: Note: This is likely where your setup will have different values. Name Type ID SmartShunt 500A/50mV battery 224 SmartSolar MPPT 150/100 solarcharger 100 (no entry name) system 100 Phoenix Inverter Compact 24/1600 vebus 227 Skylla-i 24/80A (1+1) charger 100 As can be seen from the above there is a generic, unnamed com.victron.system type device in the list with a Unit ID of 100 . This is the Cerbo GX device. The IDs have been stored inside the secrets.yaml configuration file as follows: YAML # file: secrets.yaml # victron `Unit IDs` from Modbus settings com.victronenergy.system : 100 com.victronenergy.battery : 224 com.victronenergy.vebus : 227 com.victronenergy.solarcharger : 100 Modbus Device Basic Concepts \u00b6 Reading Values \u00b6 This is explained in far more detail elsewhere, including in the Victron Energy: GC Modbus-TCP Manual , but in order to effectively utilise modbus devices we need to know both the Unit ID of the physical hardware and then the associated register address for the sensor/switch that we'd like to read/write. Whilst you can find the Unit ID above, the specifics for the registers have to be found from the manufacturers specification. In the instance of Victron they publish theirs in an Excel file that you need to download from their website. The version I am using is CCGX-Modbus-TCP-register-list-2.90 which can be found here . It'll contain information similar to the below. dbus-service-name description Address Type Scalefactor Range dbus-obj-path writable dbus-unit com.victronenergy.system Battery Voltage (System) 840 uint16 10 0 to 6553.5 /Dc/Battery/Voltage no V DC com.victronenergy.system Battery Current (System) 841 int16 10 -3276.8 to 3276.7 /Dc/Battery/Current no A DC com.victronenergy.system Battery Power (System) 842 int16 1 -32768 to 32767 /Dc/Battery/Power no W com.victronenergy.system Battery State of Charge (System) 843 uint16 1 0 to 100 /Dc/Battery/Soc no % com.victronenergy.system Battery state (System) 844 uint16 1 0 to 65536 /Dc/Battery/State no 0=idle;1=charging;2=discharging com.victronenergy.system Battery Consumed Amphours (System) 845 uint16 -10 0 to -6553.6 /Dc/Battery/ConsumedAmphours no Ah As a result, using the above information, if we wanted to read the Battery state from the system (as opposed to the smart shunt) we would need to construct a sensor inside Home Assistant that targets slave 100 and address 844 . This would provide us with an unsigned integer of 0, 1 or 2 as possible return values indicating the state of the battery (idle, charging, discharging). We can test this out quickly using raw python. Bash # create a virtual environment python -m venv env source env/venv/activate # install pymodbus pip install --upgrade pip 'pymodbus[serial]' Inside the python interpreter. Python from pymodbus.client import ModbusTcpClient client = ModbusTcpClient ( 'einstein.local' ) response = client . read_holding_registers ( 844 , slave = 100 ) print ( response . registers [ 0 ]) # first item in the register client . close () Writing Values \u00b6 In order to control modbus devices we can write to them. As we saw from the above table however all of the services in question had no in the writable column. We'll instead attempt to toggle the inverter on and off. This was on the vebus connection and the service in question we want is the Switch Position dbus-service-name description Address Type Scalefactor Range dbus-obj-path writable dbus-unit com.victronenergy.vebus Switch Position 33 uint16 1 0 to 65536 /Mode yes 1=Charger Only;2=Inverter Only;3=On;4=Off Setting the value to anything between 1 and 4 on the address 33 for slave 227 will therefore modify the state of the inverter accordingly. We can test this out quickly using raw python inside the same python interpreter from previous read steps. Python from pymodbus.client import ModbusTcpClient client = ModbusTcpClient ( 'einstein.local' ) # find current state response = client . read_holding_registers ( 33 , slave = 227 ) print ( response . registers [ 0 ]) # first item in the register # set new value to 4 (off) client . write_registers ( 33 , 4 , slave = 227 ) client . close ()","title":"ModbusTCP"},{"location":"victron/victron/#enable-modbus-tcp","text":"Go to the remote console for the Cerbo GX device and ensure Modbus is enabled (it's disabled by default). Settings >> Services >> Modbus TCP >> Select Enabled Next click into the Available services section of this menu and you should see a list of entries with familiar looking descriptions to your victron devices such as SmartShunt and associated Unit ID values (which we will require for identifying them later on). In my setup I have the following: Note: This is likely where your setup will have different values. Name Type ID SmartShunt 500A/50mV battery 224 SmartSolar MPPT 150/100 solarcharger 100 (no entry name) system 100 Phoenix Inverter Compact 24/1600 vebus 227 Skylla-i 24/80A (1+1) charger 100 As can be seen from the above there is a generic, unnamed com.victron.system type device in the list with a Unit ID of 100 . This is the Cerbo GX device. The IDs have been stored inside the secrets.yaml configuration file as follows: YAML # file: secrets.yaml # victron `Unit IDs` from Modbus settings com.victronenergy.system : 100 com.victronenergy.battery : 224 com.victronenergy.vebus : 227 com.victronenergy.solarcharger : 100","title":"Enable Modbus TCP"},{"location":"victron/victron/#modbus-device-basic-concepts","text":"","title":"Modbus Device Basic Concepts"},{"location":"victron/victron/#reading-values","text":"This is explained in far more detail elsewhere, including in the Victron Energy: GC Modbus-TCP Manual , but in order to effectively utilise modbus devices we need to know both the Unit ID of the physical hardware and then the associated register address for the sensor/switch that we'd like to read/write. Whilst you can find the Unit ID above, the specifics for the registers have to be found from the manufacturers specification. In the instance of Victron they publish theirs in an Excel file that you need to download from their website. The version I am using is CCGX-Modbus-TCP-register-list-2.90 which can be found here . It'll contain information similar to the below. dbus-service-name description Address Type Scalefactor Range dbus-obj-path writable dbus-unit com.victronenergy.system Battery Voltage (System) 840 uint16 10 0 to 6553.5 /Dc/Battery/Voltage no V DC com.victronenergy.system Battery Current (System) 841 int16 10 -3276.8 to 3276.7 /Dc/Battery/Current no A DC com.victronenergy.system Battery Power (System) 842 int16 1 -32768 to 32767 /Dc/Battery/Power no W com.victronenergy.system Battery State of Charge (System) 843 uint16 1 0 to 100 /Dc/Battery/Soc no % com.victronenergy.system Battery state (System) 844 uint16 1 0 to 65536 /Dc/Battery/State no 0=idle;1=charging;2=discharging com.victronenergy.system Battery Consumed Amphours (System) 845 uint16 -10 0 to -6553.6 /Dc/Battery/ConsumedAmphours no Ah As a result, using the above information, if we wanted to read the Battery state from the system (as opposed to the smart shunt) we would need to construct a sensor inside Home Assistant that targets slave 100 and address 844 . This would provide us with an unsigned integer of 0, 1 or 2 as possible return values indicating the state of the battery (idle, charging, discharging). We can test this out quickly using raw python. Bash # create a virtual environment python -m venv env source env/venv/activate # install pymodbus pip install --upgrade pip 'pymodbus[serial]' Inside the python interpreter. Python from pymodbus.client import ModbusTcpClient client = ModbusTcpClient ( 'einstein.local' ) response = client . read_holding_registers ( 844 , slave = 100 ) print ( response . registers [ 0 ]) # first item in the register client . close ()","title":"Reading Values"},{"location":"victron/victron/#writing-values","text":"In order to control modbus devices we can write to them. As we saw from the above table however all of the services in question had no in the writable column. We'll instead attempt to toggle the inverter on and off. This was on the vebus connection and the service in question we want is the Switch Position dbus-service-name description Address Type Scalefactor Range dbus-obj-path writable dbus-unit com.victronenergy.vebus Switch Position 33 uint16 1 0 to 65536 /Mode yes 1=Charger Only;2=Inverter Only;3=On;4=Off Setting the value to anything between 1 and 4 on the address 33 for slave 227 will therefore modify the state of the inverter accordingly. We can test this out quickly using raw python inside the same python interpreter from previous read steps. Python from pymodbus.client import ModbusTcpClient client = ModbusTcpClient ( 'einstein.local' ) # find current state response = client . read_holding_registers ( 33 , slave = 227 ) print ( response . registers [ 0 ]) # first item in the register # set new value to 4 (off) client . write_registers ( 33 , 4 , slave = 227 ) client . close ()","title":"Writing Values"}]}